{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>The Skeptic Framework is a light-weight, player-centric framework built for games by Skeptic Softworks. It was designed to allow easy access to important components from anywhere in the codebase at any time.</p> <p>Find out more about Skeptic Softworks at skepticsoftworks.com.</p> <pre><code>local Skeptic = require(game:GetService(\"ServerScriptService\").SkepticServer)\n\n-- When was Carry an Egg released?\nlocal AnswerEvent = Skeptic.Events:GetEvent(\"AnswerOnStage\")\nlocal EffectEvent = Skeptic.Events:GetEvent(\"InvokeEffect\")\n\nAnswerEvent.OnServerEvent:Connect(function(playerObject, answer)\n    if answer == \"2024\" then\n        local economy = playerObject:GetHandler(\"Economy\")\n        economy:Earn(100)\n\n        playerObject:UpdateData(\"CorrectAnswers\", function(prev)\n            prev = prev + 1\n            return prev\n        end)\n    else\n        local character = playerObject:GetHandler(\"Character\")\n        local hrp = character:GetCharacter().HumanoidRootPart\n        EffectEvent:FireAllClients(\"Explode\", hrp.Position)\n    end\nend)\n</code></pre>"},{"location":"#notes","title":"Notes","text":"<p>This documentation is relevant for Skeptic Framework V3+. Certain places use Skeptic Framework V2 or V1, which contain different methods and behavior than the ones outlines in this documentation.</p>"},{"location":"Style/","title":"Style","text":""},{"location":"Style/#overview","title":"Overview","text":"<p>Skeptic Softworks generally isn't restrictive on programming styles, but you will notice certain patterns throughout the framework.</p>"},{"location":"Style/#caveats","title":"Caveats","text":"<p>The first version of the Skeptic Framework was created for Maldives Resorts in 2023. Since then, the framework has changed massively, however there is still a lot of legacy code that is simply too valuable and time-consuming to rewrite. Therefore, there will be some quirks left over in certain methods or workflows that exist to support bits of important code, such as the massive Economy PlayerHandler, or the range of client-side modules created for the player.</p>"},{"location":"Style/#formatting","title":"Formatting","text":"Scope/type Case Base objects PascalCase Global variables PascalCase Object methods/parameters PascalCase Object constructors camelCase Arguments camelCase Other variables camelCase Example (definitely non-functional)<pre><code>local SprintObject = {}\nSprintObject.__index = SprintObject\n\nfunction SprintObject.new()\n    local self = setmetatable({}, SprintObject)\n\n    self.SomeParameter = 47.321 * 0.5 ^ 99999\n\n    return self\nend\n\nfunction SprintObject:Destroy()\n    self.SomeParameter = 0\nend\n\nlocal IsSprinting = false\n\nlocal function Sprint(fastMode)\n    local walkSpeed = 15\n    if fastMode then walkSpeed = 20 end\n\n    IsSprinting = true\n\n    local sprintObject = SprintObject.new()\n    sprintObject:Destroy() \nend\n</code></pre>"},{"location":"Style/#practices","title":"Practices","text":"<ul> <li>A fork of GoodSignal (by stravant) is used to replace standard RBXScriptSignals whenever possible.</li> <li>Objects are used often and passed around generously.</li> <li>Accessible references to objects that need to be accessed often are created\u2013 eg. all PlayerObjects are accessible with <code>:GetPlayerObject()</code> from anywhere</li> <li>Minimally destructive <code>:Destroy()</code> methods are preferred, ie. calling <code>:Destroy()</code> on an object should not break code that will try to access it in the future unless it absolutely has to.</li> <li>Generally, functions that wrap object constructors are used rather than allowing direct access to the base object.</li> <li>Historically, promises haven't been used in code with the framework, however this doesn't mean they are frowned upon. Newer work may use promises.</li> <li>Maid/janitor classes historically haven't been used either. Connections are tracked on an individual basis, though this doesn't mean these classes are frowned upon either.</li> <li>Using _G is seen as unreliable.</li> </ul> <p>And finally,</p> <ul> <li>In Madworks we trust. </li> </ul>"},{"location":"Style/#other-notes","title":"Other notes","text":"<p>Historically, source-control and tools such as Rojo have not been used in past projects, including Carry an Egg. The majority of our workflow has been within Roblox Studio besides certain external integrations, and with the new collaborative tools being released by Roblox, this hasn't been an issue so far. It has been a common practice to work on updates in a seperate development experience rather than the public experience, where updates are published to the public experience once they are tested and ready. This introduces pain points in the workflow, where if a hotfix is needed in the public experience while an update is in progress in the development experience, the changes required for the hotfix would need to be made in duplicate across both experiences.</p>"},{"location":"client/Interface/","title":"Interface","text":""},{"location":"client/Interface/#overview","title":"Overview","text":"<p>A module to handle the main Scenes object that represents much of the player's GUI.</p> <p>Info</p> <p>The documentation for this section is incomplete.</p>"},{"location":"client/SkepticClient/","title":"SkepticClient","text":""},{"location":"client/SkepticClient/#overview","title":"Overview","text":"<p>The client-side version of the Skeptic Framework. This is the only ModuleScript that needs to be required from anywhere to access the Skeptic Framework on the client.</p> Accessing SkepticClient<pre><code>local Skeptic = require(game:GetService(\"ReplicatedStorage\").SkepticClient)\n</code></pre>"},{"location":"client/SkepticClient/#properties","title":"Properties","text":""},{"location":"client/SkepticClient/#player","title":"Player","text":"<pre><code>Skeptic.Player: Player\n</code></pre> <p>A reference to <code>game:GetService(\"Players\").LocalPlayer</code>.</p>"},{"location":"client/SkepticClient/#gui","title":"GUI","text":"<pre><code>Skeptic.GUI: Frame?\n</code></pre> <p>Equivelant to <code>Skeptic.Resources.GUI</code>.</p>"},{"location":"client/SkepticClient/#resources","title":"Resources","text":"<pre><code>Skeptic.Resources: Skeptic.Resources\n</code></pre> <p>See: Resources</p>"},{"location":"client/SkepticClient/#interface","title":"Interface","text":"<pre><code>Skeptic.Interface: Skeptic.Interface\n</code></pre> <p>See: Interface</p>"},{"location":"client/SkepticClient/#events","title":"Events","text":"<pre><code>Skeptic.Events: Skeptic.Events\n</code></pre> <p>See: Events</p>"},{"location":"client/SkepticClient/#clientmodules","title":"ClientModules","text":"<pre><code>Skeptic.ClientModules: LuaSourceContainer?\n</code></pre> <p>Defined by <code>:RegisterClientModules()</code>.</p>"},{"location":"client/SkepticClient/#methods","title":"Methods","text":""},{"location":"client/SkepticClient/#registerclientmodules","title":"RegisterClientModules","text":"<pre><code>Skeptic:RegisterClientModules(\n    parent: LuaSourceContainer\n)\n</code></pre> <p>Register a reference to the location with the majority of modules used on the client-side. Will error if client modules have already been registered.</p>"},{"location":"client/SkepticClient/#updateserverloadstatus","title":"UpdateServerLoadStatus","text":"<pre><code>Skeptic:UpdateServerLoadStatus(\n    log: any\n)\n</code></pre> <p>Notify the server that the client-side has finished loading, which runs any functions bound with <code>:BindToClientLoaded()</code>.</p>"},{"location":"client/events/ClientEventWrapper/","title":"ClientEventWrapper","text":""},{"location":"client/events/ClientEventWrapper/#overview","title":"Overview","text":"<p>A client-side version of RemoteEventWrapper</p>"},{"location":"client/events/ClientEventWrapper/#events","title":"Events","text":""},{"location":"client/events/ClientEventWrapper/#onclientevent","title":"OnClientEvent","text":"<p><pre><code>event.OnClientEvent:Connect(function(\n    ...any\n) ... end)\n</code></pre> Fires when <code>:Fire*</code> is called on the server.</p>"},{"location":"client/events/ClientEventWrapper/#properties","title":"Properties","text":""},{"location":"client/events/ClientEventWrapper/#name","title":"Name","text":"<pre><code>event.Name: string\n</code></pre>"},{"location":"client/events/ClientEventWrapper/#remoteevent","title":"RemoteEvent","text":"<pre><code>event.RemoteEvent: RemoteEvent\n</code></pre>"},{"location":"client/events/ClientEventWrapper/#methods","title":"Methods","text":""},{"location":"client/events/ClientEventWrapper/#fireserver","title":"FireServer","text":"<p><pre><code>event:FireServer(\n    ...any\n)\n</code></pre> Fire an event to the server. This triggers <code>.OnServerEvent</code> on the server. </p>"},{"location":"client/events/Events/","title":"Events","text":""},{"location":"client/events/Events/#overview","title":"Overview","text":"<p>Provides methods to access ClientEventWrappers on the client-side.</p>"},{"location":"client/events/Events/#methods","title":"Methods","text":""},{"location":"client/events/Events/#geteventasync","title":"GetEventAsync","text":"<pre><code>Skeptic.Events:GetEventAsync(\n    name: string\n) -&gt; ClientEventWrapper\n</code></pre> <p>See: ClientEventWrapper</p> <p>Waits for a RemoteEvent created by <code>Skeptic.Events:GetEvent()</code> on the server and returns it as soon as possible. This method will wait for max. 30s before timing out and throwing an error.</p> <p>Warning</p> <p>RemoteEventWrappers must be created on the server before being accessed on the client.</p>"},{"location":"client/resources/Requester/","title":"Requester","text":""},{"location":"client/resources/Requester/#overview","title":"Overview","text":"<p>The Requester object is used to listen to and ask for requests from PlayerHandlers on the server. There are three ways requests are triggered:</p> <ul> <li>Calling <code>playerObject:PushRequest(someHandler)</code> from the server (See: <code>:PushRequest()</code>)</li> <li>Calling <code>requester:Request()</code> from the client (See: <code>:Request()</code>)</li> <li>Calling <code>Skeptic.Resources:RequestAsync(someHandler)</code> (See: <code>:RequestAsync</code>)</li> </ul> <p>When a request is triggered, the PlayerObject calls the <code>:Request()</code> on the specified PlayerHandler, which will return some data. This data is then sent to the client and received through functions bound to <code>requester:Listen()</code>.</p>"},{"location":"client/resources/Requester/#constructors","title":"Constructors","text":""},{"location":"client/resources/Requester/#new","title":"new","text":"<pre><code>Skeptic.Resources.Requester.new(\n    handlerName: string,\n    limit: boolean?,\n    allowServer: boolean?\n) -&gt; Skeptic.Resources.Requester\n</code></pre> <p>Creates a Requester for the given PlayerHandler.If \"limit\" is true, then only requests triggered by that Requester will be listened to, otherwise requests from any Requester for the same handler will also be accepted. If \"allowServer\" is true, then requests triggered from the server with <code>:PushRequest()</code> are accepted. This will accept requests regardless of if \"limit\" is true or not.</p>"},{"location":"client/resources/Requester/#properties","title":"Properties","text":""},{"location":"client/resources/Requester/#handler","title":"Handler","text":"<pre><code>requester.Handler: string\n</code></pre> <p>{read-only}</p> <p>The name of the PlayerHandler that this Requester is listening to.</p>"},{"location":"client/resources/Requester/#allowserver","title":"AllowServer","text":"<pre><code>requester.AllowServer: boolean\n</code></pre> <p>Whether this Requester will accept requests triggered with <code>:PushRequest()</code> from the server.</p>"},{"location":"client/resources/Requester/#id","title":"ID","text":"<pre><code>requester.ID: string\n</code></pre> <p>{read-only}</p> <p>The Requester ID used for requests triggered from the client.</p>"},{"location":"client/resources/Requester/#serverid","title":"ServerID","text":"<pre><code>requester.ServerID: string\n</code></pre> <p>{read-only}</p> <p>The Requester ID used for requests triggered from the server.</p>"},{"location":"client/resources/Requester/#methods","title":"Methods","text":""},{"location":"client/resources/Requester/#request","title":"Request","text":"<pre><code>requester:Request(\n    targets: { Player }?\n)\n</code></pre> <p>Triggers a request from the client-side. </p> <p>Warning</p> <p>The \"targets\" argument exists because of legacy functionality, and should not be used in new work.</p>"},{"location":"client/resources/Requester/#listen","title":"Listen","text":"<pre><code>requester:Listen(\n    func: (Skeptic.Requester.Response) -&gt; ()\n) -&gt; RBXScriptConnection\n</code></pre> <p>See: Response</p> <p>Listens to any incoming requests accepted by the Requester. Returns an RBXScriptConnection which can be disconnected at any time.</p>"},{"location":"client/resources/Requester/#waitforasync","title":"WaitForAsync","text":"<pre><code>requester:WaitForAsync()\n</code></pre> <p>Waits for the most recent request triggered by <code>:Request()</code> from the client. Times out at 5 seconds, and does not error. This method does not return the result of the most recent request. For async requesting, see <code>Skeptic.Resources:RequestAsync()</code>.</p>"},{"location":"client/resources/Resources/","title":"Resources","text":""},{"location":"client/resources/Resources/#overview","title":"Overview","text":"<p>This module provides a variety of utility functions to interface with the server-side PlayerObject as well as commonly access Instances on the client-side.</p>"},{"location":"client/resources/Resources/#properties","title":"Properties","text":""},{"location":"client/resources/Resources/#player","title":"Player","text":"<pre><code>Skeptic.Resources.Player: Player\n</code></pre> <p>A reference to <code>game:GetService(\"Players\").LocalPlayer</code>.</p>"},{"location":"client/resources/Resources/#gui","title":"GUI","text":"<pre><code>Skeptic.Resources.GUI: Frame\n</code></pre> <p>A reference to <code>game &gt; Players &gt; [LocalPlayer] &gt; PlayerGui &gt; Skeptic_UI &gt; Container</code>. This can be <code>nil</code> if being accessed very early after the player joins. </p> <p></p> <p>Info</p> <p>This is the only layout that the framework will understand. This way, full intellisense is retained when accessing <code>Skeptic.Resources.GUI</code>.</p> <p>Warning</p> <p>To be sure that this won't be <code>nil</code>, please use <code>:WaitForGuiAsync()</code>. In most cases, however, it is safe to assume this won't be nil.</p>"},{"location":"client/resources/Resources/#requester","title":"Requester","text":"<pre><code>Skeptic.Resources.Requester: Skeptic.Resources.Requester\n</code></pre> <p>See: Requester</p> <p>A reference to the base Requester object. New Requesters must be created with this, using <code>Resources.Requester.new(...)</code>.</p>"},{"location":"client/resources/Resources/#methods","title":"Methods","text":""},{"location":"client/resources/Resources/#waitforguiasync","title":"WaitForGuiAsync","text":"<pre><code>Skeptic.Resources:WaitForGuiAsync() -&gt; Frame\n</code></pre> <p>Waits for then returns the player's container GUI frame. Times out after 16 seconds, but if a scenario like that ever occurs, then a missing frame will be the least of your problems.</p>"},{"location":"client/resources/Resources/#waitforserverasync","title":"WaitForServerAsync","text":"<pre><code>Skeptic.Resources:WaitForServerAsync() -&gt; serverLoaded: boolean, firstTime: boolean\n</code></pre> <p>Waits for the server-side PlayerObject to indicate that loading has finished. \"serverLoaded\" should always be true, and \"firstTime\" is true if, according to their player data, it is the player's first time playing that game.</p> <p>In the catastrophic scenario that \"serverLoaded\" is false, then the method timed out after at least 76 seconds of giving the server a chance. This has yet to happen in a live game, but please make sure your PlayerHandlers don't yield infinitely.</p>"},{"location":"client/resources/Resources/#preloadassets","title":"PreloadAssets","text":"<pre><code>Skeptic.Resources:PreloadAssets(\n    callback: (asset: any, status: Enum.AssetFetchStatus, ratio: number) -&gt; ()\n)\n</code></pre> <p>Preloads assets in Instances with the \"PreloadPriority\" tag. See CollectionService for more on using tags in Roblox. Does not yield. The \"callback\" function will be called for each asset loaded, with the \"ratio\" argument indicating the ratio of completed assets (ie. 0.5 = 50%, 1 = 100% of assets loaded).</p>"},{"location":"client/resources/Resources/#requestasync","title":"RequestAsync","text":"<pre><code>Skeptic.Resources:RequestAsync(\n    handlerName: string,\n    targets: { Player }?\n) -&gt; any?\n</code></pre> <p>Asynchronously trigger a request for any PlayerHandler on the server. </p> <p>Warning</p> <p>The \"targets\" argument should not be used for newer work, and should be left as <code>nil</code>.</p>"},{"location":"client/resources/Response/","title":"Response","text":""},{"location":"client/resources/Response/#overview","title":"Overview","text":"<p>Represents the response for a request received by the client. </p>"},{"location":"client/resources/Response/#properties","title":"Properties","text":""},{"location":"client/resources/Response/#data","title":"Data","text":"<pre><code>response.Data: { [Player]: any }\n</code></pre> <p>The data in the response. <code>:GetPersonal()</code> should be used rather than this.</p>"},{"location":"client/resources/Response/#reqid","title":"ReqId","text":"<pre><code>response.ReqId: string\n</code></pre> <p>Always equivelant to the <code>requester.ID</code> of the requester that received this response.</p>"},{"location":"client/resources/Response/#serverinvoked","title":"ServerInvoked","text":"<pre><code>response.ServerInvoked: boolean\n</code></pre> <p>Is <code>true</code> if this request was created with <code>:PushRequest()</code> from the server.</p>"},{"location":"client/resources/Response/#methods","title":"Methods","text":""},{"location":"client/resources/Response/#get","title":"Get","text":"<pre><code>response:Get(\n    player: Player\n) -&gt; any\n</code></pre> <p>{deprecated}</p> <p><code>:GetPersonal()</code> should be used in place of this in newer work.</p>"},{"location":"client/resources/Response/#getpersonal","title":"GetPersonal","text":"<pre><code>response:GetPersonal() -&gt; any\n</code></pre> <p>Returns the data passed in the request. Will be equivelant to the return value of <code>playerHandler:Request()</code>.</p>"},{"location":"server/Analytics/","title":"Analytics","text":""},{"location":"server/Analytics/#overview","title":"Overview","text":"<p>This module acts as a wrapper for Roblox's AnalyticsService.</p> <p>Info</p> <p>The documentation for this section is incomplete.</p>"},{"location":"server/Feedback/","title":"Feedback","text":""},{"location":"server/Feedback/#overview","title":"Overview","text":"<p>This module allows players to submit feedback and modcalls directly to the developers with a Discord webhook. The messages given to these methods are filtered behind the scenes to block spam as much as possible.</p> <p>These methods do not need to be directly used. By default, two Events are created: \"SendFeedback\" and \"SendModcall\". Example usage: Client-side script<pre><code>local event = Skeptic.Events:GetEventAsync(\"SendFeedback\")\nevent:FireServer(\"Feedback\", \"Fix ur game!!\", game:GetService(\"LogService\"):GetLogHistory())\n</code></pre></p> <p>Warning</p> <p>These methods are not ratelimited. Please account for Discord ratelimits.</p>"},{"location":"server/Feedback/#methods","title":"Methods","text":""},{"location":"server/Feedback/#sendfeedback","title":"SendFeedback","text":"<pre><code>Skeptic.Feedback:SendFeedback(\n    sender: Player,\n    sendType: string, \n    message: string,\n    consoleOutput: {any}?\n) -&gt; success: boolean, blocked: boolean\n</code></pre> <p>Submit feedback to the webhook, automatically formatted into an embed behind the scenes.</p> <p>\"sendType\" must be either <code>\"Bug Report\"</code>, <code>\"Feedback\"</code> or <code>\"Suggestion\"</code>.</p> <p>\"consoleOutput\" must be the raw return value of <code>game:GetService(\"LogService\"):GetLogHistory()</code>.</p> <p>\"success\" is <code>true</code> if the submission was considered successful. \"blocked\" is <code>true</code> if the submission was blocked. In this case, \"success\" will always be true, despite the submission technically failing.</p> <p>Info</p> <p>\"success\" should always be used as the user-facing status of the submission. The player should not be able to see if their feedback was blocked or not.</p>"},{"location":"server/Feedback/#modcall","title":"ModCall","text":"<pre><code>Skeptic.Feedback:ModCall(\n    sender: Player, \n    message: string\n) -&gt; success: boolean, blocked: boolean\n</code></pre> <p>Submit a modcall to the webhook, mainly for reporting player behavior. </p> <p>The return behavior is identical to that of <code>:SendFeedback()</code>.</p>"},{"location":"server/SkepticServer/","title":"SkepticServer","text":""},{"location":"server/SkepticServer/#overview","title":"Overview","text":"<p>The client-side version of the Skeptic Framework. This is the only ModuleScript that needs to be required from anywhere to access the Skeptic Framework on the client.</p> Accessing SkepticServer<pre><code>local Skeptic = require(game:GetService(\"ServerScriptService\").SkepticServer)\n</code></pre>"},{"location":"server/SkepticServer/#events","title":"Events","text":""},{"location":"server/SkepticServer/#playerjoined","title":"PlayerJoined","text":"<pre><code>Skeptic.PlayerJoined:Connect(function(\n    playerObject: Skeptic.PlayerObject\n) ... end)\n</code></pre> <p>See: PlayerObject</p> <p>Fires when a player joins and when their PlayerObject is minimally initialized. </p> <p>Info</p> <p>The player's data and PlayerHandlers may not be immediately available when this event fires. </p>"},{"location":"server/SkepticServer/#playerleft","title":"PlayerLeft","text":"<pre><code>Skeptic.PlayerLeft:Connect(function(\n    player: Player\n) ... end)\n</code></pre> <p>Fires when a player leaves. </p> <p>Warning</p> <p>Their PlayerObject technically unloads after this event fires, however it is unsafe to assume that their data or PlayerHandlers will still be accessible as normal. Unless necessary, unloading logic should be handled in PlayerHandlers with <code>playerObject:BindToLeave()</code></p>"},{"location":"server/SkepticServer/#properties","title":"Properties","text":""},{"location":"server/SkepticServer/#players","title":"Players","text":"<pre><code>Skeptic.Players: Skeptic.Players\n</code></pre> <p>See: Players</p>"},{"location":"server/SkepticServer/#events_1","title":"Events","text":"<pre><code>Skeptic.Events: Skeptic.Events\n</code></pre> <p>See: Events</p>"},{"location":"server/SkepticServer/#version","title":"Version","text":"<pre><code>Skeptic.Version: Skeptic.Version\n</code></pre> <p>See: Version</p>"},{"location":"server/SkepticServer/#analytics","title":"Analytics","text":"<pre><code>Skeptic.Analytics: Skeptic.Analytics\n</code></pre> <p>See: Analytics</p>"},{"location":"server/VersionPage/","title":"Version","text":""},{"location":"server/VersionPage/#overview","title":"Overview","text":"<p>This module contains methods to view the server and experience-wide version of the place. </p>"},{"location":"server/VersionPage/#properties","title":"Properties","text":""},{"location":"server/VersionPage/#localversion","title":"LocalVersion","text":"<pre><code>Skeptic.Version.LocalVersion: {any}\n</code></pre> <p>{read-only}</p> <p>The currently stored server and experience versions. </p> <p>Info</p> <p>This shouldn't be directly accessed. Use the dedicated methods instead please.</p>"},{"location":"server/VersionPage/#methods","title":"Methods","text":""},{"location":"server/VersionPage/#getserverversion","title":"GetServerVersion","text":"<pre><code>Skeptic.Version:GetServerVersion() -&gt; string\n</code></pre> <p>Returns the version of the experience in this server. This will either be the same as or older than the experience version.</p>"},{"location":"server/VersionPage/#getexperienceversion","title":"GetExperienceVersion","text":"<pre><code>Skeptic.Version:GetExperienceVersion() -&gt; string\n</code></pre> <p>Returns the experience-wide version. This will only be up-to-date when the server starts up. Use <code>:UpdateValuesAsync</code> to get the latest version data from the DataStore.</p>"},{"location":"server/VersionPage/#updatevaluesasync","title":"UpdateValuesAsync","text":"<pre><code>Skeptic.Version:UpdateValuesAsync(\n    timeOut: number?\n) -&gt; boolean\n</code></pre> <p>Updates the experience version value from the DataStore. Calling this will take about 1-2 seconds, so wrap it in <code>task.spawn</code> if needed.</p>"},{"location":"server/VersionPage/#getservervaluesage","title":"GetServerValuesAge","text":"<pre><code>Skeptic.Version:GetServerValuesAge() -&gt; number\n</code></pre> <p>Returns the time, in seconds, since <code>:UpdateValuesAsync</code> was last called.</p>"},{"location":"server/events/Events/","title":"Events","text":""},{"location":"server/events/Events/#overview","title":"Overview","text":"<p>An advanced wrapper for RemoteEvents, with support for custom Validators and automatic references to PlayerObjects.</p>"},{"location":"server/events/Events/#default-events","title":"Default Events","text":"<p>There are several EventWrappers created and used by the framework internally.</p> Name Usage Request Internal LoadStatus Internal UpdateDevice Internal SendModcall See: Feedback SendFeedback See: Feedback <p>Warning</p> <p>Any EventWrappers with the \"Internal\" usage tag must be avoided. </p>"},{"location":"server/events/Events/#types","title":"Types","text":""},{"location":"server/events/Events/#argumentfilter","title":"ArgumentFilter","text":"<p><pre><code>local argumentFilter: {\n    { \n        Type: string?, \n        Callback: (any) -&gt; (boolean)?\n    }\n} = ...\n</code></pre> The ArgumentFilter type is a table of tables, where each item in the table represents an expected argument when an event is received on the server.</p> <p>\"Type\" can be a type name (eg. <code>\"string\"</code>) or <code>\"any\"</code> in order to accept anything except for <code>nil</code>. \"Callback\" can be a callback function that returns <code>true</code> if the received argument is accepted.</p>"},{"location":"server/events/Events/#methods","title":"Methods","text":""},{"location":"server/events/Events/#getevent","title":"GetEvent","text":"<pre><code>Skeptic.Events:GetEvent(\n    name: string\n) -&gt; Skeptic.Events.RemoteEventWrapper\n</code></pre> <p>See: RemoteEventWrapper</p> <p>Returns the RemoteEventWrapper by name. Creates one if one does not exist yet. There can only be one RemoteEventWrapper with any given name.</p>"},{"location":"server/events/Events/#geteventifexists","title":"GetEventIfExists","text":"<pre><code>Skeptic.Events:GetEventIfExists(\n    name: string\n) -&gt; Skeptic.Events.RemoteEventWrapper?\n</code></pre> <p>See: RemoteEventWrapper</p> <p>Returns the RemoteEventWrapper by name, but returns <code>nil</code> if one with that name has not been created yet.</p>"},{"location":"server/events/Events/#destroyevent","title":"DestroyEvent","text":"<pre><code>Skeptic.Events:DestroyEvent(\n    name: string\n)\n</code></pre> <p>Destroys the RemoteEventWrapper with that name if it exists.</p> <p>Warning</p> <p>This does not automatically disconnect client-side connections to this event. Avoid using this method at all.</p>"},{"location":"server/events/Events/#createvalidator","title":"CreateValidator","text":"<pre><code>Skeptic.Events:CreateValidator(\n    argumentFilter: ArgumentFilter?\n): Skeptic.Events.RemoteEventValidator\n</code></pre> <p>See: RemoteEventValidator, ArgumentFilter</p> <p>Creates a RemoteEventValidator to be used for RemoteEventWrappers created by this module.</p>"},{"location":"server/events/RemoteEventValidator/","title":"RemoteEventValidator","text":""},{"location":"server/events/RemoteEventValidator/#overview","title":"Overview","text":"<p>This object checks the arguments of every event received on any RemoteEventWrappers that it is attached to, and blocks the event from firing <code>.OnServerEvent</code> in the case that one of the arguments don't pass. A single RemoteEventValidator can be used with multiple RemoteEventWrappers.</p>"},{"location":"server/events/RemoteEventValidator/#events","title":"Events","text":""},{"location":"server/events/RemoteEventValidator/#servereventblocked","title":"ServerEventBlocked","text":"<pre><code>validator.ServerEventBlocked:Connect(function(\n    eventWrapper: Skeptic.Events.RemoteEventWrapper,\n    playerObject: Skeptic.PlayerObject,\n    reason: string,\n    blockedArgument: any?\n) ... end)\n</code></pre> <p>See: RemoteEventWrapper</p> <p>Fires whenever any RemoteEventWrapper using this RemoteEventValidator is blocked by the validator.</p>"},{"location":"server/events/RemoteEventValidator/#properties","title":"Properties","text":""},{"location":"server/events/RemoteEventValidator/#argumentfilter","title":"ArgumentFilter","text":"<pre><code>validator.ArgumentFilter: ArgumentFilter\n</code></pre> <p>See: ArgumentFilter</p> <p>Refers to the ArgumentFilter table being used by this validator. Can be changed at any time to another valid ArgumentFilter. This should never be nil.</p>"},{"location":"server/events/RemoteEventValidator/#methods","title":"Methods","text":""},{"location":"server/events/RemoteEventValidator/#validatearguments","title":"ValidateArguments","text":"<pre><code>validator:ValidateArguments(\n    eventWrapper: Skeptic.Events.RemoteEventWrapper,\n    playerObject: Skeptic.PlayerObject,\n    ...: any\n) -&gt; pass: boolean, reason: string?, blockedArgument: any?\n</code></pre> <p>See: RemoteEventWrapper</p> <p>Manually validate the arguments passed in an event from a player. \"pass\" will be <code>false</code> if at least one of the arguments don't pass. \"reason\" will be a short message specifying why the first invalid argument was blocked, and \"blockedArgument\" will be the value of the invalid argument. \"reason\" and \"blockedArgument\" are nil if \"pass\" is <code>true</code>.</p> <p>Info</p> <p>This is already done automatically by RemoteEventWrappers with a validator attached to them with :SetValidator.</p>"},{"location":"server/events/RemoteEventValidator/#destroy","title":"Destroy","text":"<pre><code>validator:Destroy()\n</code></pre> <p>Destroys the RemoteEventValidator and disconnects connections. RemoteEventWrappers with this validator will no longer be blocked after this is called.</p>"},{"location":"server/events/RemoteEventWrapper/","title":"RemoteEventWrapper","text":""},{"location":"server/events/RemoteEventWrapper/#overview","title":"Overview","text":"<p>This object is a wrapper for RemoteEvents. To access the client-side version of the RemoteEventWrapper created on the server, use <code>Skeptic.Events:GetEventAsnyc()</code>.</p>"},{"location":"server/events/RemoteEventWrapper/#events","title":"Events","text":""},{"location":"server/events/RemoteEventWrapper/#onserverevent","title":"OnServerEvent","text":"<pre><code>event.OnServerEvent:Connect(function(\n    playerObject: Skeptic.PlayerObject,\n    ...: any\n) ... end)\n</code></pre> <p>Fires when a client calls <code>event:FireServer(...)</code>.</p>"},{"location":"server/events/RemoteEventWrapper/#servereventblocked","title":"ServerEventBlocked","text":"<pre><code>event.ServerEventBlocked:Connect(function(\n    playerObject: Skeptic.PlayerObject,\n    reason: string,\n    blockedArgument: any?\n) ... end)\n</code></pre> <p>See: RemoteEventValidator</p> <p>Fires when an event is blocked by the RemoteEventValidator. </p>"},{"location":"server/events/RemoteEventWrapper/#properties","title":"Properties","text":""},{"location":"server/events/RemoteEventWrapper/#name","title":"Name","text":"<p><pre><code>event.Name: string\n</code></pre> The name of the RemoteEventWrapper.</p>"},{"location":"server/events/RemoteEventWrapper/#remoteevent","title":"RemoteEvent","text":"<pre><code>event.RemoteEvent: RemoteEvent\n</code></pre> <p>A reference to the actual RemoteEvent created by the wrapper. </p> <p>Warning</p> <p>Avoid directly accessing this RemoteEvent, as lots of functionality is reliant on aspects of it on both the server- and client-side.</p>"},{"location":"server/events/RemoteEventWrapper/#methods","title":"Methods","text":""},{"location":"server/events/RemoteEventWrapper/#fireclient","title":"FireClient","text":"<pre><code>event:FireClient(\n    player: Player | Skeptic.PlayerObject,\n    ...: any\n)\n</code></pre> <p>Fire an event to a specific client.</p>"},{"location":"server/events/RemoteEventWrapper/#fireclients","title":"FireClients","text":"<pre><code>event:FireClients(\n    players: { Player | Skeptic.PlayerObject },\n    ...: any\n)\n</code></pre> <p>Fire an event to a list of clients.</p>"},{"location":"server/events/RemoteEventWrapper/#fireallclients","title":"FireAllClients","text":"<pre><code>event:FireAllClients(\n    ...: any\n)\n</code></pre> <p>Fire an event to all clients loaded in the server.</p>"},{"location":"server/events/RemoteEventWrapper/#fireallexcept","title":"FireAllExcept","text":"<pre><code>event:FireAllExcept(\n    player: Player | Skeptic.PlayerObject,\n    ...: any\n)\n</code></pre> <p>Fire an event to all clients except the one specified.</p>"},{"location":"server/events/RemoteEventWrapper/#setvalidator","title":"SetValidator","text":"<p><pre><code>event:SetValidator(\n    validator: Skeptic.Events.RemoteEventValidator\n)\n</code></pre> See: RemoteEventValidator</p> <p>Assign a RemoteEventValidator to this event. Any arguments from an event that do not pass the validator will cause that event to be blocked. In this case, ServerEventBlocked will fire.</p>"},{"location":"server/players/PlayerHandler/","title":"PlayerHandler","text":""},{"location":"server/players/PlayerHandler/#overview","title":"Overview","text":"<p>A PlayerHandler is a unique object created for each player in the game. They can only be accessed using <code>playerObject:GetHandler()</code>.</p>"},{"location":"server/players/PlayerHandler/#creating-a-playerhandler","title":"Creating a PlayerHandler","text":"<p>PlayerHandlers are standard Luau objects that are created as soon as possible for each player that joins the server. They are defined by a function that returns a table to initialize as a PlayerHandler. This function is defined with <code>Skeptic.Players:AddPlayerHandler()</code>.</p> <p>Warning</p> <p>PlayerHandlers must be defined immediately when the server starts in order to be created for every player that will join the server. Players that joined before a PlayerHandler is defined will not have that handler created for them.</p> Example PlayerHandler<pre><code>-- Money Handler\n-- Methods for earning and spending money\n\nlocal PlayerMoney = {}\nPlayerMoney.__index = PlayerMoney\n\nlocal Skeptic = require(game:GetService(\"ServerScriptService\").SkepticServer)\n\n-- Define the data key for money\nSkeptic.Players:DefineDataTemplateKey(\"Money\", 0)\n\n-- Define the handler\nSkeptic.Players:AddPlayerHandler(\"Money\", function(playerObject)\n    local self = setmetatable({}, PlayerMoney)\n\n    -- The amount of money earned in this session\n    self.SessionEarnings = 0\n\n    return self\nend)\n\nfunction PlayerMoney:Request()\n    return {\n        Money = self.PlayerObject:GetData(\"Money\"),\n        SessionEarnings = self.SessionEarnings\n    }\nend\n\nfunction PlayerMoney:TrySpend(amount: number): boolean\n    local money = self.PlayerObject:GetData(\"Money\")\n    if money &gt;= amount then\n        self.PlayerObject:UpdateData(\"Money\", function(prev)\n            return prev - amount\n        end)\n\n        -- Update the client with the new amount of money\n        self.PlayerObject:PushRequest(self)\n\n        return true\n    else\n        return false\n    end\nend\n\nfunction PlayerMoney:Earn(amount: number)\n    self.PlayerObject:UpdateData(\"Money\", function(prev)\n        return prev + amount\n    end)\n\n    self.SessionEarnings += amount\n\n    -- Update the client with the new amount of money\n    self.PlayerObject:PushRequest(self)\nend\n\nreturn PlayerMoney\n</code></pre> <p>In the example above, as soon as the \"onPlayerAdded\" function returns the \"PlayerMoney\" object, it is initialized with default properties and methods, such as <code>.PlayerObject</code>.</p> <p><code>:Request()</code> is defined in the example so that it returns the money owned by the player, as well as the amount they earned in that session. Every time <code>playerObject:PushRequest()</code> is called, the result of this function will be sent to the client, who will receive it via any Requester that is listening to that handler.</p>"},{"location":"server/players/PlayerHandler/#properties","title":"Properties","text":""},{"location":"server/players/PlayerHandler/#name","title":"Name","text":"<pre><code>playerHandler.Name: string\n</code></pre>"},{"location":"server/players/PlayerHandler/#player","title":"Player","text":"<pre><code>playerHandler.Player: Player\n</code></pre>"},{"location":"server/players/PlayerHandler/#playerobject","title":"PlayerObject","text":"<p><pre><code>playerHandler.PlayerObject: Skeptic.PlayerObject\n</code></pre> See: PlayerObject</p>"},{"location":"server/players/PlayerHandler/#methods","title":"Methods","text":""},{"location":"server/players/PlayerHandler/#request","title":"Request","text":"<pre><code>playerHandler:Request(\n    requestedBy: Player\n) -&gt; any\n</code></pre> <p>See: Requester, <code>playerObject:PushRequest()</code></p> <p>This method should return any data that the client may need at any time. If <code>:Request</code> is not defined in the PlayerHandler definition, an empty function will be created by default.</p> <p>The \"requestedBy\" argument will always be the player that owns the PlayerHandler. It is a legacy argument from V2 and below, and shouldn't be used in new work.</p>"},{"location":"server/players/PlayerObject/","title":"PlayerObject","text":""},{"location":"server/players/PlayerObject/#overview","title":"Overview","text":"<p>A wrapper for the Player Instance, created automatically for each player in the server. This holds references to all PlayerHandlers created for the player, as well as important methods to manage player data and more. This is a core component of the Skeptic Framework.</p>"},{"location":"server/players/PlayerObject/#properties","title":"Properties","text":""},{"location":"server/players/PlayerObject/#player","title":"Player","text":"<pre><code>playerObject.Player: Player\n</code></pre> <p>{read-only}</p> <p>A reference to the Player.</p>"},{"location":"server/players/PlayerObject/#profile","title":"Profile","text":"<pre><code>playerObject.Profile: any\n</code></pre> <p>A reference to the ProfileService Profile created for this player.</p>"},{"location":"server/players/PlayerObject/#methods","title":"Methods","text":""},{"location":"server/players/PlayerObject/#gethandler","title":"GetHandler","text":"<pre><code>playerObject:GetHandler(\n    handlerName: string\n) -&gt; Skeptic.PlayerHandler\n</code></pre> <p>See: PlayerHandler</p> <p>Returns a PlayerHandler by name, if it exists.</p> <p>Warning</p> <p>Some handlers will take time to load, and may not be immediately available. Please use <code>:BindToLoaded</code> to guarantee that all handlers will be loaded.</p>"},{"location":"server/players/PlayerObject/#tunnel","title":"Tunnel","text":"<pre><code>playerObject:Tunnel(\n    handlerName: string,\n    method: string,\n    ...: any\n)\n</code></pre> <p>Run a method in a handler. Will error if the handler does not exist yet. Generally, <code>:GetHandler</code> should be used in place of this.</p>"},{"location":"server/players/PlayerObject/#pushrequest","title":"PushRequest","text":"<pre><code>playerObject:PushRequest(\n    handler: string | Skeptic.PlayerHandler,\n    alterCallback: (any) -&gt; (any?)\n)\n</code></pre> <p>See: Requester</p> <p>Push a request from the given handler to the client. \"alterCallback\" accepts the value returned by <code>playerHandler:Request()</code>, and returns a new value to replace it. If \"alterCallback\" returns <code>nil</code>, then it is ignored and the original value will be returned anyway.</p>"},{"location":"server/players/PlayerObject/#bindtoloaded","title":"BindToLoaded","text":"<pre><code>playerObject:BindToLoaded(\n    fn: () -&gt; ()\n)\n</code></pre> <p>Bind a function to run when this PlayerObject finishes loading, and when <code>playerObject:IsServerLoaded()</code> returns true.</p>"},{"location":"server/players/PlayerObject/#bindtoclientloaded","title":"BindToClientLoaded","text":"<pre><code>playerObject:BindToClientLoaded(\n    fn: () -&gt; ()\n)\n</code></pre> <p>Bind a function to run when the client fires an event to indicate they mostly finished loading, and when <code>playerObject:IsClientLoaded()</code> returns true.</p>"},{"location":"server/players/PlayerObject/#bindtoleave","title":"BindToLeave","text":"<pre><code>playerObject:BindToLeave(\n    fn: () -&gt; ()\n)\n</code></pre> <p>Bind a function to run when the player leaves the server. Functions bound here will run after their Profile is released (their data is unloaded), and before their PlayerHandlers are cleared.</p> <p>Info</p> <p>Modifying data in a function passed to <code>:BindToLeave()</code> is not guaranteed to save the data. All data should be saved immediately as they are modified, and should not be applied before the player leaves.</p> <p>Warning</p> <p>The PlayerObject will run all functions bound here one-by-one until they are complete before clearing PlayerHandlers and removing the reference to the PlayerObject. Ensure that these binds do not error and yield for as little possible, if absolutely necessary.</p>"},{"location":"server/players/PlayerObject/#isserverloaded","title":"IsServerLoaded","text":"<pre><code>playerObject:IsServerLoaded() -&gt; boolean\n</code></pre> <p>Returns true when all their PlayerHandlers and the player's Profile are loaded.</p>"},{"location":"server/players/PlayerObject/#isclientloaded","title":"IsClientLoaded","text":"<pre><code>playerObject:IsClientLoaded() -&gt; boolean\n</code></pre> <p>Returns true if the player has indicated with a RemoteEvent that they finished loading. This method is not guaranteed to accurately represent the client-side state.</p>"},{"location":"server/players/PlayerObject/#isingame","title":"IsInGame","text":"<pre><code>playerObject:IsInGame() -&gt; boolean\n</code></pre> <p>Returns true if the player has not yet left the game. Will only return false after they left the game, regardless of if they're loaded in or not.</p>"},{"location":"server/players/PlayerObject/#getdata","title":"GetData","text":"<pre><code>playerObject:GetData(\n    key: string\n) -&gt; any?\n</code></pre> <p>See: Skeptic.Players:DefineDataTemplateKey()</p> <p>Returns a deepcopy of the data stored in that key. </p> <p>Info</p> <p>This method is guaranteed to return either the most recently saved value or the default value defined by <code>:DefineDataTemplateKey()</code>. </p>"},{"location":"server/players/PlayerObject/#updatedata","title":"UpdateData","text":"<pre><code>playerObject:UpdateData(\n    key: string,\n    updateFn: (any) -&gt; (any?) \n)\n</code></pre> <p>See: Skeptic.Players:DefineDataTemplateKey()</p> <p>Update a key in the players data. This method does not yield. </p> <p>\"updateFn\" accepts a deepcopy of the previously saved data as the only argument, and returns the new data to be saved in that key. If <code>nil</code> is returned, then the operation is cancelled and the data is unsaved.</p> <p>Info</p> <p>You can assume that data updated with this function will always save. With over 230 million total visits, we have yet to hear any reports of data loss.</p>"},{"location":"server/players/PlayerObject/#logcustomevent","title":"LogCustomEvent","text":"<pre><code>playerObject:LogCustomEvent(\n    eventName: string,\n    value: number?,\n    customFields: { [string]: any }?\n)\n</code></pre> <p>See: Analytics</p>"},{"location":"server/players/PlayerObject/#logonboardingfunnelstep","title":"LogOnboardingFunnelStep","text":"<pre><code>playerObject:LogOnboardingFunnelStep(\n    stepId: string,\n    customFields: { [string]: any }?\n)\n</code></pre> <p>See: Analytics</p>"},{"location":"server/players/PlayerObject/#beginfunnelsession","title":"BeginFunnelSession","text":"<pre><code>playerObject:BeginFunnelSession(\n    funnelName: string,\n    sessionId: string?\n) -&gt; any\n</code></pre> <p>See: Analytics</p>"},{"location":"server/players/Players/","title":"Players","text":""},{"location":"server/players/Players/#overview","title":"Overview","text":"<p>The Player module contains methods to access PlayerObjects and access or define PlayerHandlers. </p>"},{"location":"server/players/Players/#properties","title":"Properties","text":""},{"location":"server/players/Players/#playerprofilestore","title":"PlayerProfileStore","text":"<pre><code>Skeptic.Players.PlayerProfileStore: any\n</code></pre> <p>A reference to the ProfileStore created for player data managed by the framework.</p>"},{"location":"server/players/Players/#profileservice","title":"ProfileService","text":"<pre><code>Skeptic.Players.ProfileService: any\n</code></pre> <p>A reference to the framework's version of ProfileService. ProfileService is a player data management module created by Mad Studio.</p>"},{"location":"server/players/Players/#methods","title":"Methods","text":""},{"location":"server/players/Players/#getplayerobject","title":"GetPlayerObject","text":"<pre><code>Skeptic.Players:GetPlayerObject(\n    player: Player\n) -&gt; Skeptic.PlayerObject?\n</code></pre> <p>See: PlayerObject</p> <p>Returns the PlayerObject given the Player in the server, if it exists.</p>"},{"location":"server/players/Players/#getplayerhandler","title":"GetPlayerHandler","text":"<pre><code>Skeptic.Players:GetPlayerHandler(\n    player: Player,\n    handler: string\n) -&gt; Skeptic.PlayerHandler?\n</code></pre> <p>See: PlayerHandler</p> <p>Returns the relevant PlayerHandler for that player, if it exists. This simply calls <code>GetPlayerObject(player):GetHandler(handler)</code> behind the scenes.</p>"},{"location":"server/players/Players/#isplayeringame","title":"IsPlayerInGame","text":"<pre><code>Skeptic.Players:IsPlayerInGame(\n    player: Player | Skeptic.PlayerObject\n) -&gt; boolean\n</code></pre> <p>Returns <code>true</code> if the player currently has a loaded PlayerObject in this server. Any Instance or table can be passed.</p>"},{"location":"server/players/Players/#getplayers","title":"GetPlayers","text":"<pre><code>Skeptic.Players:GetPlayers() -&gt; { Skeptic.PlayerObject }\n</code></pre> <p>See: PlayerObject</p> <p>Returns a table of PlayerObjects that are currently loaded in the server.</p>"},{"location":"server/players/Players/#definedatatemplatekey","title":"DefineDataTemplateKey","text":"<pre><code>Skeptic.Players:DefineDataTemplateKey(\n    key: string,\n    default: any\n)\n</code></pre> <p>Defines a key that will be present in all players' data. By default, this key will have the default value given in the function. Calling <code>PlayerObject:GetData(key)</code> after using this function will return the previously saved value or the default value provided, even if that player did not have that data key before.</p>"},{"location":"server/players/Players/#lockdatatemplate","title":"LockDataTemplate","text":"<pre><code>Skeptic.Players:LockDataTemplate()\n</code></pre> <p>Locks the DataTemplate and provides the template table to ProfileService. Attempting to call <code>DefineDataTemplateKey</code> after calling this will throw an error.</p> <p>Info</p> <p>This method must be called once any relevant scripts have finished defining DataTemplate keys in order for the keys to appear in player data.</p>"},{"location":"server/players/Players/#addplayerhandler","title":"AddPlayerHandler","text":"<pre><code>Skeptic.Players:AddPlayerHandler(\n    name: string,\n    onPlayerAdded: (playerObject: Skeptic.PlayerObject) -&gt; ({ any })\n)\n</code></pre> <p>See: PlayerHandler, Creating a PlayerHandler</p> <p>Defines a function to create a PlayerHandler with the given name. Calling <code>playerObject:GetHandler(name)</code>) will return the result of the \"onPlayerAdded\" function, initialized with the default properties of PlayerHandlers. </p>"},{"location":"server/players/Players/#addplayerhandlerpreinitialized","title":"AddPlayerHandlerPreInitialized","text":"<pre><code>Skeptic.Players:AddPlayerHandlerPreInitialized(\n    name: string,\n    onPlayerAdded: (baseHandler: Skeptic.PlayerHandler) -&gt; ({ any })\n)\n</code></pre> <p>Defines a function to create a PlayerHandler with the given name. Rather than passing the PlayerObject, this passes an initialized PlayerHandler object to be modified.</p> <p>Warning</p> <p>This method was created to support handlers created before V3. <code>:AddPlayerHandler()</code> should always be used in new work.</p>"}]}